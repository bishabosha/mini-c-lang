[x] check scope for undeclared identifier access
[x] frame based scoping
    [x] flat frame field on functions
    [x] stack based scope structure in context
[>] a-normal form
    [x] constant folding
        [x] binary expression of constants
        [x] fold unary operator of constant
[x] return is tail
[x] bindings cursor
[x] interpreter of ast
[x] Need to encode in the current frame an id for each variable or temporary
[x] replace temporaries having inner values with assignments to a temporary,
    or else awful lalr descent will be needed
[ ] Type check as an interpreter step
[>] tac
    [ ] Normal form of function application using recursion
        [x] Add frame field to function
        [x] Definition of func should be in scope for applications,
            [x] whole block must be examined first (bearing in mind forward
                declarations) 
    [>] variables to be assigned at most once?
        [?] do have key value pairs of scope and identifier
    so that its current register can be recorded
[ ] global variable name conflicts (with mips instructions) please remove
[ ] create data segment at ast stage
[ ] Do global data at AST level
[?] Consider adding temporaries to the frame
[ ] only use Cursor in a terminal consumer

--- FOR REPORT ---

[ ] everything I removed from C.y
[ ] talk about WASM
[ ] changed data segment parsing from end to the start
[ ] previously temporaries contained nested expressions,
    bad for mapping as no canonical reference

[ ] need to fix recursion in ast node visiting

[>] improve mips speed
    [ ] bitset for used temp registers, use numbers not enums

[>] improve parse time
    [ ] polyglot_import("astToScala") or something like such
    [ ] specialised form of CAst to reduce match time
    [?] possible solution to global stack in mycc is to have a map that for
        each build process can allot a new bucket.
    [-] use node to make --C build server and replace main in Parser.scala
        [-] or try to send C callbacks to scala
    [?] no bison at all?